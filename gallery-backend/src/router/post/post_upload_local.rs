use crate::operations::open_db::open_data_table;
use crate::public::constant::storage::get_data_path;
use crate::public::error::{AppError, ErrorKind};
use crate::public::structure::abstract_data::AbstractData;
use crate::public::structure::common::FileModify;
use crate::public::structure::image::{ImageCombined, ImageMetadata};
use crate::public::structure::object::{ObjectSchema, ObjectType};
use crate::router::fairing::guard_read_only_mode::GuardReadOnlyMode;
use crate::router::fairing::guard_upload::GuardUpload;
use crate::router::{AppResult, GuardResult};
use crate::tasks::BATCH_COORDINATOR;
use crate::tasks::batcher::flush_tree::FlushTreeTask;
use anyhow::Result;
use arrayvec::ArrayString;
use chrono::Utc;
use rocket::form::{Errors, Form};
use rocket::fs::TempFile;
use std::collections::{BTreeMap, HashSet};
use std::fs;
use std::mem;

/// Form for local-first upload with processed metadata
#[derive(FromForm, Debug)]
pub struct UploadLocalForm<'r> {
    /// Serialized JSON metadata
    #[field(name = "metadata")]
    pub metadata: String,

    /// Compressed image (JPEG) generated by WASM
    #[field(name = "compressed")]
    pub compressed: TempFile<'r>,

    /// Original file
    #[field(name = "original")]
    pub original: TempFile<'r>,
}

/// Metadata fully calculated by Frontend/WASM
/// Backend treats this as the source of truth without re-verification
#[derive(serde::Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ProcessedMetadata {
    pub hash: String,
    pub width: u32,
    pub height: u32,
    pub size: u64,
    pub extension: String, // Received from WASM
    pub thumbhash: Option<Vec<u8>>,
    pub phash: Option<Vec<u8>>,
    pub exif: BTreeMap<String, String>,
    pub last_modified: i64, // Mandatory from WASM
}

#[post("/upload-local?<presigned_album_id_opt>", data = "<form>")]
pub async fn upload_local(
    auth: GuardResult<GuardUpload>,
    read_only_mode: GuardResult<GuardReadOnlyMode>,
    presigned_album_id_opt: Option<String>,
    form: Result<Form<UploadLocalForm<'_>>, Errors<'_>>,
) -> AppResult<()> {
    let _ = auth?;
    let _ = read_only_mode?;

    let mut inner_form = match form {
        Ok(f) => f.into_inner(),
        Err(e) => {
            return Err(AppError::new(
                ErrorKind::InvalidInput,
                format!("Form error: {:?}", e),
            ));
        }
    };

    // 1. Deserialize Metadata (Source of Truth)
    let meta: ProcessedMetadata = serde_json::from_str(&inner_form.metadata).map_err(|e| {
        AppError::new(
            ErrorKind::InvalidInput,
            format!("Invalid metadata JSON: {}", e),
        )
    })?;

    let hash_str = &meta.hash;
    let hash = ArrayString::from(hash_str)
        .map_err(|_| AppError::new(ErrorKind::InvalidInput, "Hash too long"))?;

    // 2. Prepare Storage Paths
    let root = get_data_path();
    let hash_prefix = &hash_str[0..2];

    // Imported Path: object/imported/xx/hash.ext
    let imported_dir = root.join(format!("object/imported/{}", hash_prefix));
    let imported_path = imported_dir.join(format!("{}.{}", hash_str, meta.extension));

    // Compressed Path: object/compressed/xx/hash.jpg
    let compressed_dir = root.join(format!("object/compressed/{}", hash_prefix));
    let compressed_path = compressed_dir.join(format!("{}.jpg", hash_str));

    // 3. Save Files (I/O Only)
    fs::create_dir_all(&imported_dir).map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // Save Original
    inner_form
        .original
        .move_copy_to(&imported_path)
        .await
        .map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // Apply Timestamp to File System
    let mtime = filetime::FileTime::from_unix_time((meta.last_modified / 1000) as i64, 0);
    let _ = filetime::set_file_mtime(&imported_path, mtime);

    // Save Compressed
    fs::create_dir_all(&compressed_dir).map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;
    inner_form
        .compressed
        .move_copy_to(&compressed_path)
        .await
        .map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // 4. Construct Data Structures (Mapping Only)
    let current_server_time = Utc::now().timestamp_millis();
    let mut albums = HashSet::new();

    if let Some(aid) = presigned_album_id_opt {
        if let Ok(aid_array) = ArrayString::from(&aid) {
            albums.insert(aid_array);
        }
    }

    // Object Schema - Directly map from meta
    let object = ObjectSchema {
        id: hash,
        obj_type: ObjectType::Image,
        pending: false,
        thumbhash: meta.thumbhash,
        description: None,
        tags: HashSet::new(),
        is_favorite: false,
        is_archived: false,
        is_trashed: false,
        update_at: current_server_time, // Server sets update time, file keeps original time
    };

    // Metadata - Directly map from meta
    let mut metadata = ImageMetadata {
        id: hash,
        size: meta.size,
        width: meta.width,
        height: meta.height,
        ext: meta.extension.clone(),
        phash: meta.phash,
        albums,
        exif_vec: meta.exif,
        alias: vec![], // Populated below
    };

    // FileModify - Directly map from meta + temp file logic
    // We still need the original filename string, which comes from the form upload
    let original_filename_base = inner_form
        .original
        .name()
        .map(std::string::ToString::to_string)
        .unwrap_or_else(|| "unknown".to_string());

    let file_modify = FileModify {
        file: format!("{}.{}", original_filename_base, meta.extension),
        modified: meta.last_modified,
        scan_time: current_server_time,
    };
    metadata.alias.push(file_modify);

    let mut abstract_data = AbstractData::Image(ImageCombined { object, metadata });

    // 5. DB Insertion / Merge Logic (Storage Logic)
    let data_table = open_data_table();

    if let Some(guard) = data_table.get(&*hash).unwrap() {
        // Exists: Merge logic
        let mut data_exist = guard.value();

        if let Some(new_alias_mut) = abstract_data.alias_mut() {
            if !new_alias_mut.is_empty() {
                let new_fm = mem::take(&mut new_alias_mut[0]);
                if let Some(exist_alias) = data_exist.alias_mut() {
                    exist_alias.push(new_fm);
                }
            }
        }

        if let Some(new_albums) = abstract_data.albums() {
            if let Some(exist_albums) = data_exist.albums_mut() {
                for alb in new_albums {
                    exist_albums.insert(*alb);
                }
            }
        }

        BATCH_COORDINATOR.execute_batch_detached(FlushTreeTask::insert(vec![data_exist]));
    } else {
        // New: Insert directly
        BATCH_COORDINATOR.execute_batch_detached(FlushTreeTask::insert(vec![abstract_data]));
    }

    Ok(())
}
