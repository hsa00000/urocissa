use crate::operations::open_db::open_data_table;
use crate::public::constant::storage::EnvironmentManager;
use crate::public::error::{AppError, ErrorKind};
use crate::public::structure::abstract_data::AbstractData;
use crate::public::structure::image::{ImageCombined, ImageMetadata};
use crate::public::structure::object::ObjectSchema;
use crate::router::fairing::guard_read_only_mode::GuardReadOnlyMode;
use crate::router::fairing::guard_upload::GuardUpload;
use crate::router::{AppResult, GuardResult};
use crate::tasks::BATCH_COORDINATOR;
use crate::tasks::batcher::flush_tree::FlushTreeTask;
use rocket::form::{Errors, Form};
use rocket::fs::TempFile;
use std::fs;
use std::mem;

/// Form for local-first upload with processed metadata
#[derive(FromForm, Debug)]
pub struct UploadLocalForm<'r> {
    /// Serialized JSON metadata
    #[field(name = "metadata")]
    pub metadata: String,

    /// Compressed image (JPEG) generated by WASM
    #[field(name = "compressed")]
    pub compressed: TempFile<'r>,

    /// Original file
    #[field(name = "original")]
    pub original: TempFile<'r>,
}

/// Payload fully calculated by Frontend/WASM.
/// Backend treats this as the source of truth without re-mapping.
#[derive(serde::Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct UploadLocalPayload {
    pub object: ObjectSchema,
    pub metadata: ImageMetadata,
}

#[post("/upload-local", data = "<form>")]
pub async fn upload_local(
    auth: GuardResult<GuardUpload>,
    read_only_mode: GuardResult<GuardReadOnlyMode>,
    form: Result<Form<UploadLocalForm<'_>>, Errors<'_>>,
) -> AppResult<()> {
    let _ = auth?;
    let _ = read_only_mode?;

    let mut inner_form = match form {
        Ok(f) => f.into_inner(),
        Err(e) => {
            return Err(AppError::new(
                ErrorKind::InvalidInput,
                format!("Form error: {:?}", e),
            ));
        }
    };

    // 1. Deserialize Payload (Source of Truth)
    let payload: UploadLocalPayload = serde_json::from_str(&inner_form.metadata).map_err(|e| {
        AppError::new(
            ErrorKind::InvalidInput,
            format!("Invalid metadata JSON: {}", e),
        )
    })?;

    let hash = payload.object.id;
    let hash_str = hash.as_str();

    // 2. Prepare Storage Paths
    // Imported Path: object/imported/xx/hash.ext
    let imported_dir = EnvironmentManager::object_imported_prefix_dir(hash_str);
    let imported_path = EnvironmentManager::imported_file_path(hash_str, &payload.metadata.ext);

    // Compressed Path: object/compressed/xx/hash.jpg
    let compressed_dir = EnvironmentManager::object_compressed_prefix_dir(hash_str);
    let compressed_path = EnvironmentManager::compressed_file_path(hash_str, "jpg");

    // 3. Save Files (I/O Only)
    fs::create_dir_all(&imported_dir).map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // Save Original
    inner_form
        .original
        .move_copy_to(&imported_path)
        .await
        .map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // Apply Timestamp to File System
    // Intentionally do not override filesystem mtime here.

    // Save Compressed
    fs::create_dir_all(&compressed_dir).map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;
    inner_form
        .compressed
        .move_copy_to(&compressed_path)
        .await
        .map_err(|e| AppError::new(ErrorKind::IO, e.to_string()))?;

    // 4. Construct Data Structures (No mapping; accept client payload)
    let mut abstract_data = AbstractData::Image(ImageCombined {
        object: payload.object,
        metadata: payload.metadata,
    });

    // 5. DB Insertion / Merge Logic (Storage Logic)
    let data_table = open_data_table();

    if let Some(guard) = data_table.get(&*hash).unwrap() {
        // Exists: Merge logic
        let mut data_exist = guard.value();

        if let Some(new_alias_mut) = abstract_data.alias_mut() {
            if !new_alias_mut.is_empty() {
                let new_fm = mem::take(&mut new_alias_mut[0]);
                if let Some(exist_alias) = data_exist.alias_mut() {
                    exist_alias.push(new_fm);
                }
            }
        }

        if let Some(new_albums) = abstract_data.albums() {
            if let Some(exist_albums) = data_exist.albums_mut() {
                for alb in new_albums {
                    exist_albums.insert(*alb);
                }
            }
        }

        BATCH_COORDINATOR.execute_batch_detached(FlushTreeTask::insert(vec![data_exist]));
    } else {
        // New: Insert directly
        BATCH_COORDINATOR.execute_batch_detached(FlushTreeTask::insert(vec![abstract_data]));
    }

    Ok(())
}
